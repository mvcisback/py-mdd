<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>mdd.mdd API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mdd.mdd</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

import re
import itertools
import uuid
from functools import reduce
from typing import Any, Callable, Dict, Hashable
from typing import Iterable, Optional, Sequence, Set, Tuple, Union
from typing import FrozenSet

import aiger_bv as BV
import aiger_bdd
import attr
from aiger_bv.bundle import Bundle
from aiger_bv.expr import UnsignedBVExpr
from attr._make import Attribute
from dd.autoref import BDD


Assignment = Tuple[Dict[str, Any], Any]

INDEX_SPLITTER = re.compile(r&#34;(.*)\[(.*)\]&#34;)


@attr.s(frozen=True, auto_attribs=True)
class Variable:
    &#34;&#34;&#34;BDD representation of a multi-valued variable.&#34;&#34;&#34;

    valid: BV.UnsignedBVExpr = attr.ib()
    encode: Callable[[Any], int]
    decode: Callable[[int], Any]

    def size(self) -&gt; int:
        &#34;&#34;&#34;Returns number of values Variable can take on.&#34;&#34;&#34;
        return aiger_bdd.count(self.valid)

    @valid.validator
    def check_bitvector_input(self, _: Attribute, value: UnsignedBVExpr):
        if len(value.inputs) != 1:
            raise ValueError(&#34;valid must be over single bitvector input!&#34;)

    @property
    def _name_bundle(self) -&gt; Tuple[str, int]:
        imap = self.valid.aigbv.imap
        (name, bundle), *_ = imap.items()
        return name, bundle

    @property
    def name(self) -&gt; str:
        return self._name_bundle[0]

    @property
    def bundle(self) -&gt; Bundle:
        return self.valid.aigbv.imap[self.name]

    def with_name(self, name: str) -&gt; Variable:
        &#34;&#34;&#34;Create a copy of this Variable with a new name.&#34;&#34;&#34;
        if self.name == name:
            return self
        valid_circ = self.valid.aigbv[&#34;i&#34;, {self.name: name}]
        return attr.evolve(self, valid=BV.UnsignedBVExpr(valid_circ))

    @property
    def _encoding_size(self) -&gt; int:
        return self.bundle.size

    def expr(self) -&gt; BV.UnsignedBVExpr:
        &#34;&#34;&#34;Returns Aiger BitVector representing this variable.&#34;&#34;&#34;
        return BV.uatom(self._encoding_size, self.name)


VariableLike = Union[Sequence[Hashable], Variable]


def pow2_exponent(val: int) -&gt; int:
    &#34;&#34;&#34;Compute exponent of power of 2.&#34;&#34;&#34;
    count = 0
    while val &gt; 1:
        count += 1
        val &gt;&gt;= 1
    assert val == 1
    return count


def to_bdd(circ_or_expr, manager: Optional[BDD] = None) -&gt; BDD:
    &#34;&#34;&#34;Convert py-aiger compatible object into a BDD.&#34;&#34;&#34;
    return aiger_bdd.to_bdd(circ_or_expr, manager=manager, renamer=lambda _, x: x)[0]


Domain = Union[Iterable[Any], Variable]


def to_var(domain: Domain, name: Optional[str] = None) -&gt; Variable:
    &#34;&#34;&#34;Create a named variable taking on values in `domain`.
    
    Uses a 1-hot encoding of domain, i.e., one variable per
    element. For more efficient encoding consider creating Variable
    directly.

    If `name is None`, then unique name selected when creating
    Variable.
    &#34;&#34;&#34;
    if isinstance(domain, Variable):
        return domain if (name is None) else domain.with_name(name)
    if name is None:
        name = str(uuid.uuid1())  # Create unique name.

    domain = tuple(domain)
    tmp = BV.atom(len(domain), name, signed=True)

    # Create circuit representing classic onehot bit trick.
    one_hot = (tmp != 0) &amp; ((tmp &amp; (tmp - 1)) == 0)
    one_hot = BV.UnsignedBVExpr(one_hot.aigbv)  # Forget about sign.

    return Variable(
        valid=one_hot.with_output(&#34;valid&#34;),
        encode=lambda val: 1 &lt;&lt; domain.index(val),
        decode=lambda val: domain[pow2_exponent(val)],
    )


Variables = Dict[str, Variable]


def to_vars(vals: Union[Iterable[Variable], Dict[str, Domain]]) -&gt; Variables:
    if isinstance(vals, dict):
        vals = (to_var(name=key, domain=value) for key, value in vals.items())
    return {var.name: var for var in vals}


@attr.s(frozen=True, auto_attribs=True)
class Interface:
    &#34;&#34;&#34;Input output interface of Multi-valued Decision Diagram.&#34;&#34;&#34;

    _inputs: Variables = attr.ib(converter=to_vars)
    output: Variable = attr.ib(converter=to_var)
    applied: FrozenSet[str] = frozenset()

    def __attrs_post_init__(self):
        names = list(self._inputs.keys()) + [self.output.name]
        if len(names) != len(set(names)):
            raise ValueError(&#34;All input names must be unique!&#34;)

    @property
    def inputs(self) -&gt; Iterable[Variable]:
        return [var for var in self._inputs.values()]

    def valid(self) -&gt; BV.UnsignedBVExpr:
        &#34;&#34;&#34;Circuit testing if input assignment is valid.&#34;&#34;&#34;
        valid_tests = (var.valid for var in self.inputs)
        return reduce(lambda x, y: x &amp; y, valid_tests)

    def constantly(self, output: Any, manager: Optional[BDD] = None) -&gt; MDD:
        &#34;&#34;&#34;Return MDD returns `output` for any input.&#34;&#34;&#34;
        encoded = self.output.encode(output)
        assert self.output.valid({self.output.name: encoded})[0]

        # Create BDD that only depends on hot variable in encoded.
        index = pow2_exponent(encoded)
        expr = self.output.expr()[index] &amp; self.valid()
        bdd = to_bdd(expr, manager=manager)
        return DecisionDiagram(interface=self, bdd=bdd)

    def lift(self, bdd_or_aig, manager: None = None) -&gt; MDD:
        &#34;&#34;&#34;Wrap bdd or py-aiger object using this interface.
        
        Note: Output is assumed to be 1-hot encoded!
        &#34;&#34;&#34;
        if hasattr(bdd_or_aig, &#34;aig&#34;):
            bdd = to_bdd(bdd_or_aig)

        return DecisionDiagram(interface=self, bdd=bdd)

    def var(self, name: str) -&gt; Variable:
        &#34;&#34;&#34;Get `Variable` for `name` in this interface.&#34;&#34;&#34;
        return self._inputs.get(name, self.output)


@attr.s(frozen=True, auto_attribs=True)
class DecisionDiagram:
    interface: Interface
    bdd: BDD

    def __attrs_post_init__(self):
        &#34;&#34;&#34;Check that bdd conforms to interface.&#34;&#34;&#34;
        bdd_vars: Set[str] = set(self.bdd.bdd.vars)
        interface_vars: Set[str] = set()

        io = self.interface
        for var in itertools.chain(io.inputs, [io.output]):
            interface_vars |= set(var.bundle)

        if bdd_vars != interface_vars:
            diff = bdd_vars.symmetric_difference(interface_vars)
            raise ValueError(
                &#34;Input AIG or BDD does not agree with this&#34;
                f&#34;interface.\n symmetric difference={diff}&#34;
            )

    def let(self, inputs: Dict[str, Any]) -&gt; MDD:
        &#34;&#34;&#34;Return MDD where subset of inputs have been applied.&#34;&#34;&#34;
        vals: Dict[str, bool] = {}
        for name, value in inputs.items():
            var = self.interface.var(name)
            encoded = var.encode(value)
            assert var.valid({var.name: encoded})[0]

            # Turn bitvector into individual assignments.
            bundle = var.bundle
            encoded = BV.encode_int(bundle.size, encoded, signed=False)
            vals.update(bundle.blast(encoded))

        bdd = self.bdd.let(**vals)

        io = self.interface
        io2 = attr.evolve(io, applied=io.applied | set(inputs))
        return attr.evolve(self, bdd=bdd, interface=io2)

    def __call__(self, inputs: Dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Evaluate MDD on inputs.&#34;&#34;&#34;
        bdd = self.let(inputs).bdd
        assert bdd.dag_size == 2, &#34;Result should be single variable BDD.&#34;

        # Return which decision this was.
        match = INDEX_SPLITTER.match(bdd.var)
        assert match is not None
        name, idx_str = match.groups()
        idx = int(idx_str)
        output_var = self.interface.output
        assert name == output_var.name
        assert 0 &lt;= idx &lt; output_var._encoding_size
        return output_var.decode(1 &lt;&lt; idx)

    def order(self, var_names: Sequence[str]):
        &#34;&#34;&#34;Reorder underlying BDD to respect order seen in inputs.

        As a side effect, this function turns off reordering.
        &#34;&#34;&#34;
        io = self.interface
        levels: Dict[str, int] = {}
        for name in var_names:
            offset = len(levels)

            var = io._inputs.get(name, io.output)
            assert var.name == name, &#34;Name doesn&#39;t match input or output.&#34;

            size = var._encoding_size
            levels.update(var.bundle.blast(range(offset, offset + size)))

        assert len(levels) == len(self.bdd.bdd.vars)
        self.bdd.bdd.reorder(levels)
        self.bdd.bdd.configure(reordering=False)

    def override(self, test, value: Union[Any, MDD]) -&gt; MDD:
        &#34;&#34;&#34;Return MDD where `value if test else self`.

        Args:
          test: Can be a BDD or and py-aiger compatible object.
          value: Either an element of co-domain or another compatible
                 MDD.
        &#34;&#34;&#34;
        manager = self.bdd.bdd
        if not isinstance(value, DecisionDiagram):
            value = self.interface.constantly(value, manager=manager).bdd

        if hasattr(test, &#34;aig&#34;):
            test = to_bdd(test, manager=manager)

        # Assuming test and value are BDDs now.
        #         test =&gt; value    ~test =&gt; self.bdd.
        bdd = ((~test) | value) &amp; (test | self.bdd)
        return attr.evolve(self, bdd=bdd)


MDD = DecisionDiagram


__all__ = [&#34;DecisionDiagram&#34;, &#34;Interface&#34;, &#34;Variable&#34;, &#34;to_var&#34;, &#34;to_bdd&#34;]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mdd.mdd.to_bdd"><code class="name flex">
<span>def <span class="ident">to_bdd</span></span>(<span>circ_or_expr, manager: Optional[BDD] = None) ‑> dd.autoref.BDD</span>
</code></dt>
<dd>
<div class="desc"><p>Convert py-aiger compatible object into a BDD.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_bdd(circ_or_expr, manager: Optional[BDD] = None) -&gt; BDD:
    &#34;&#34;&#34;Convert py-aiger compatible object into a BDD.&#34;&#34;&#34;
    return aiger_bdd.to_bdd(circ_or_expr, manager=manager, renamer=lambda _, x: x)[0]</code></pre>
</details>
</dd>
<dt id="mdd.mdd.to_var"><code class="name flex">
<span>def <span class="ident">to_var</span></span>(<span>domain: Domain, name: Optional[str] = None) ‑> <a title="mdd.mdd.Variable" href="#mdd.mdd.Variable">Variable</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a named variable taking on values in <code>domain</code>.</p>
<p>Uses a 1-hot encoding of domain, i.e., one variable per
element. For more efficient encoding consider creating Variable
directly.</p>
<p>If <code>name is None</code>, then unique name selected when creating
Variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_var(domain: Domain, name: Optional[str] = None) -&gt; Variable:
    &#34;&#34;&#34;Create a named variable taking on values in `domain`.
    
    Uses a 1-hot encoding of domain, i.e., one variable per
    element. For more efficient encoding consider creating Variable
    directly.

    If `name is None`, then unique name selected when creating
    Variable.
    &#34;&#34;&#34;
    if isinstance(domain, Variable):
        return domain if (name is None) else domain.with_name(name)
    if name is None:
        name = str(uuid.uuid1())  # Create unique name.

    domain = tuple(domain)
    tmp = BV.atom(len(domain), name, signed=True)

    # Create circuit representing classic onehot bit trick.
    one_hot = (tmp != 0) &amp; ((tmp &amp; (tmp - 1)) == 0)
    one_hot = BV.UnsignedBVExpr(one_hot.aigbv)  # Forget about sign.

    return Variable(
        valid=one_hot.with_output(&#34;valid&#34;),
        encode=lambda val: 1 &lt;&lt; domain.index(val),
        decode=lambda val: domain[pow2_exponent(val)],
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mdd.mdd.DecisionDiagram"><code class="flex name class">
<span>class <span class="ident">DecisionDiagram</span></span>
<span>(</span><span>interface: <a title="mdd.mdd.Interface" href="#mdd.mdd.Interface">Interface</a>, bdd: BDD)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DecisionDiagram:
    interface: Interface
    bdd: BDD

    def __attrs_post_init__(self):
        &#34;&#34;&#34;Check that bdd conforms to interface.&#34;&#34;&#34;
        bdd_vars: Set[str] = set(self.bdd.bdd.vars)
        interface_vars: Set[str] = set()

        io = self.interface
        for var in itertools.chain(io.inputs, [io.output]):
            interface_vars |= set(var.bundle)

        if bdd_vars != interface_vars:
            diff = bdd_vars.symmetric_difference(interface_vars)
            raise ValueError(
                &#34;Input AIG or BDD does not agree with this&#34;
                f&#34;interface.\n symmetric difference={diff}&#34;
            )

    def let(self, inputs: Dict[str, Any]) -&gt; MDD:
        &#34;&#34;&#34;Return MDD where subset of inputs have been applied.&#34;&#34;&#34;
        vals: Dict[str, bool] = {}
        for name, value in inputs.items():
            var = self.interface.var(name)
            encoded = var.encode(value)
            assert var.valid({var.name: encoded})[0]

            # Turn bitvector into individual assignments.
            bundle = var.bundle
            encoded = BV.encode_int(bundle.size, encoded, signed=False)
            vals.update(bundle.blast(encoded))

        bdd = self.bdd.let(**vals)

        io = self.interface
        io2 = attr.evolve(io, applied=io.applied | set(inputs))
        return attr.evolve(self, bdd=bdd, interface=io2)

    def __call__(self, inputs: Dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;Evaluate MDD on inputs.&#34;&#34;&#34;
        bdd = self.let(inputs).bdd
        assert bdd.dag_size == 2, &#34;Result should be single variable BDD.&#34;

        # Return which decision this was.
        match = INDEX_SPLITTER.match(bdd.var)
        assert match is not None
        name, idx_str = match.groups()
        idx = int(idx_str)
        output_var = self.interface.output
        assert name == output_var.name
        assert 0 &lt;= idx &lt; output_var._encoding_size
        return output_var.decode(1 &lt;&lt; idx)

    def order(self, var_names: Sequence[str]):
        &#34;&#34;&#34;Reorder underlying BDD to respect order seen in inputs.

        As a side effect, this function turns off reordering.
        &#34;&#34;&#34;
        io = self.interface
        levels: Dict[str, int] = {}
        for name in var_names:
            offset = len(levels)

            var = io._inputs.get(name, io.output)
            assert var.name == name, &#34;Name doesn&#39;t match input or output.&#34;

            size = var._encoding_size
            levels.update(var.bundle.blast(range(offset, offset + size)))

        assert len(levels) == len(self.bdd.bdd.vars)
        self.bdd.bdd.reorder(levels)
        self.bdd.bdd.configure(reordering=False)

    def override(self, test, value: Union[Any, MDD]) -&gt; MDD:
        &#34;&#34;&#34;Return MDD where `value if test else self`.

        Args:
          test: Can be a BDD or and py-aiger compatible object.
          value: Either an element of co-domain or another compatible
                 MDD.
        &#34;&#34;&#34;
        manager = self.bdd.bdd
        if not isinstance(value, DecisionDiagram):
            value = self.interface.constantly(value, manager=manager).bdd

        if hasattr(test, &#34;aig&#34;):
            test = to_bdd(test, manager=manager)

        # Assuming test and value are BDDs now.
        #         test =&gt; value    ~test =&gt; self.bdd.
        bdd = ((~test) | value) &amp; (test | self.bdd)
        return attr.evolve(self, bdd=bdd)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="mdd.mdd.DecisionDiagram.bdd"><code class="name">var <span class="ident">bdd</span> : dd.autoref.BDD</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="mdd.mdd.DecisionDiagram.interface"><code class="name">var <span class="ident">interface</span> : <a title="mdd.mdd.Interface" href="#mdd.mdd.Interface">Interface</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mdd.mdd.DecisionDiagram.let"><code class="name flex">
<span>def <span class="ident">let</span></span>(<span>self, inputs: Dict[str, Any]) ‑> <a title="mdd.mdd.DecisionDiagram" href="#mdd.mdd.DecisionDiagram">DecisionDiagram</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return MDD where subset of inputs have been applied.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def let(self, inputs: Dict[str, Any]) -&gt; MDD:
    &#34;&#34;&#34;Return MDD where subset of inputs have been applied.&#34;&#34;&#34;
    vals: Dict[str, bool] = {}
    for name, value in inputs.items():
        var = self.interface.var(name)
        encoded = var.encode(value)
        assert var.valid({var.name: encoded})[0]

        # Turn bitvector into individual assignments.
        bundle = var.bundle
        encoded = BV.encode_int(bundle.size, encoded, signed=False)
        vals.update(bundle.blast(encoded))

    bdd = self.bdd.let(**vals)

    io = self.interface
    io2 = attr.evolve(io, applied=io.applied | set(inputs))
    return attr.evolve(self, bdd=bdd, interface=io2)</code></pre>
</details>
</dd>
<dt id="mdd.mdd.DecisionDiagram.order"><code class="name flex">
<span>def <span class="ident">order</span></span>(<span>self, var_names: Sequence[str])</span>
</code></dt>
<dd>
<div class="desc"><p>Reorder underlying BDD to respect order seen in inputs.</p>
<p>As a side effect, this function turns off reordering.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def order(self, var_names: Sequence[str]):
    &#34;&#34;&#34;Reorder underlying BDD to respect order seen in inputs.

    As a side effect, this function turns off reordering.
    &#34;&#34;&#34;
    io = self.interface
    levels: Dict[str, int] = {}
    for name in var_names:
        offset = len(levels)

        var = io._inputs.get(name, io.output)
        assert var.name == name, &#34;Name doesn&#39;t match input or output.&#34;

        size = var._encoding_size
        levels.update(var.bundle.blast(range(offset, offset + size)))

    assert len(levels) == len(self.bdd.bdd.vars)
    self.bdd.bdd.reorder(levels)
    self.bdd.bdd.configure(reordering=False)</code></pre>
</details>
</dd>
<dt id="mdd.mdd.DecisionDiagram.override"><code class="name flex">
<span>def <span class="ident">override</span></span>(<span>self, test, value: Union[Any, MDD]) ‑> <a title="mdd.mdd.DecisionDiagram" href="#mdd.mdd.DecisionDiagram">DecisionDiagram</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return MDD where <code>value if test else self</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>test</code></strong></dt>
<dd>Can be a BDD or and py-aiger compatible object.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Either an element of co-domain or another compatible
MDD.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def override(self, test, value: Union[Any, MDD]) -&gt; MDD:
    &#34;&#34;&#34;Return MDD where `value if test else self`.

    Args:
      test: Can be a BDD or and py-aiger compatible object.
      value: Either an element of co-domain or another compatible
             MDD.
    &#34;&#34;&#34;
    manager = self.bdd.bdd
    if not isinstance(value, DecisionDiagram):
        value = self.interface.constantly(value, manager=manager).bdd

    if hasattr(test, &#34;aig&#34;):
        test = to_bdd(test, manager=manager)

    # Assuming test and value are BDDs now.
    #         test =&gt; value    ~test =&gt; self.bdd.
    bdd = ((~test) | value) &amp; (test | self.bdd)
    return attr.evolve(self, bdd=bdd)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdd.mdd.Interface"><code class="flex name class">
<span>class <span class="ident">Interface</span></span>
<span>(</span><span>inputs, output, applied: FrozenSet[str] = frozenset())</span>
</code></dt>
<dd>
<div class="desc"><p>Input output interface of Multi-valued Decision Diagram.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Interface:
    &#34;&#34;&#34;Input output interface of Multi-valued Decision Diagram.&#34;&#34;&#34;

    _inputs: Variables = attr.ib(converter=to_vars)
    output: Variable = attr.ib(converter=to_var)
    applied: FrozenSet[str] = frozenset()

    def __attrs_post_init__(self):
        names = list(self._inputs.keys()) + [self.output.name]
        if len(names) != len(set(names)):
            raise ValueError(&#34;All input names must be unique!&#34;)

    @property
    def inputs(self) -&gt; Iterable[Variable]:
        return [var for var in self._inputs.values()]

    def valid(self) -&gt; BV.UnsignedBVExpr:
        &#34;&#34;&#34;Circuit testing if input assignment is valid.&#34;&#34;&#34;
        valid_tests = (var.valid for var in self.inputs)
        return reduce(lambda x, y: x &amp; y, valid_tests)

    def constantly(self, output: Any, manager: Optional[BDD] = None) -&gt; MDD:
        &#34;&#34;&#34;Return MDD returns `output` for any input.&#34;&#34;&#34;
        encoded = self.output.encode(output)
        assert self.output.valid({self.output.name: encoded})[0]

        # Create BDD that only depends on hot variable in encoded.
        index = pow2_exponent(encoded)
        expr = self.output.expr()[index] &amp; self.valid()
        bdd = to_bdd(expr, manager=manager)
        return DecisionDiagram(interface=self, bdd=bdd)

    def lift(self, bdd_or_aig, manager: None = None) -&gt; MDD:
        &#34;&#34;&#34;Wrap bdd or py-aiger object using this interface.
        
        Note: Output is assumed to be 1-hot encoded!
        &#34;&#34;&#34;
        if hasattr(bdd_or_aig, &#34;aig&#34;):
            bdd = to_bdd(bdd_or_aig)

        return DecisionDiagram(interface=self, bdd=bdd)

    def var(self, name: str) -&gt; Variable:
        &#34;&#34;&#34;Get `Variable` for `name` in this interface.&#34;&#34;&#34;
        return self._inputs.get(name, self.output)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="mdd.mdd.Interface.applied"><code class="name">var <span class="ident">applied</span> : FrozenSet[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="mdd.mdd.Interface.output"><code class="name">var <span class="ident">output</span> : <a title="mdd.mdd.Variable" href="#mdd.mdd.Variable">Variable</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="mdd.mdd.Interface.inputs"><code class="name">var <span class="ident">inputs</span> : Iterable[<a title="mdd.mdd.Variable" href="#mdd.mdd.Variable">Variable</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def inputs(self) -&gt; Iterable[Variable]:
    return [var for var in self._inputs.values()]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mdd.mdd.Interface.constantly"><code class="name flex">
<span>def <span class="ident">constantly</span></span>(<span>self, output: Any, manager: Optional[BDD] = None) ‑> <a title="mdd.mdd.DecisionDiagram" href="#mdd.mdd.DecisionDiagram">DecisionDiagram</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return MDD returns <code>output</code> for any input.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constantly(self, output: Any, manager: Optional[BDD] = None) -&gt; MDD:
    &#34;&#34;&#34;Return MDD returns `output` for any input.&#34;&#34;&#34;
    encoded = self.output.encode(output)
    assert self.output.valid({self.output.name: encoded})[0]

    # Create BDD that only depends on hot variable in encoded.
    index = pow2_exponent(encoded)
    expr = self.output.expr()[index] &amp; self.valid()
    bdd = to_bdd(expr, manager=manager)
    return DecisionDiagram(interface=self, bdd=bdd)</code></pre>
</details>
</dd>
<dt id="mdd.mdd.Interface.lift"><code class="name flex">
<span>def <span class="ident">lift</span></span>(<span>self, bdd_or_aig, manager: None = None) ‑> <a title="mdd.mdd.DecisionDiagram" href="#mdd.mdd.DecisionDiagram">DecisionDiagram</a></span>
</code></dt>
<dd>
<div class="desc"><p>Wrap bdd or py-aiger object using this interface.</p>
<p>Note: Output is assumed to be 1-hot encoded!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lift(self, bdd_or_aig, manager: None = None) -&gt; MDD:
    &#34;&#34;&#34;Wrap bdd or py-aiger object using this interface.
    
    Note: Output is assumed to be 1-hot encoded!
    &#34;&#34;&#34;
    if hasattr(bdd_or_aig, &#34;aig&#34;):
        bdd = to_bdd(bdd_or_aig)

    return DecisionDiagram(interface=self, bdd=bdd)</code></pre>
</details>
</dd>
<dt id="mdd.mdd.Interface.valid"><code class="name flex">
<span>def <span class="ident">valid</span></span>(<span>self) ‑> aiger_bv.expr.UnsignedBVExpr</span>
</code></dt>
<dd>
<div class="desc"><p>Circuit testing if input assignment is valid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def valid(self) -&gt; BV.UnsignedBVExpr:
    &#34;&#34;&#34;Circuit testing if input assignment is valid.&#34;&#34;&#34;
    valid_tests = (var.valid for var in self.inputs)
    return reduce(lambda x, y: x &amp; y, valid_tests)</code></pre>
</details>
</dd>
<dt id="mdd.mdd.Interface.var"><code class="name flex">
<span>def <span class="ident">var</span></span>(<span>self, name: str) ‑> <a title="mdd.mdd.Variable" href="#mdd.mdd.Variable">Variable</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get <code><a title="mdd.mdd.Variable" href="#mdd.mdd.Variable">Variable</a></code> for <code>name</code> in this interface.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def var(self, name: str) -&gt; Variable:
    &#34;&#34;&#34;Get `Variable` for `name` in this interface.&#34;&#34;&#34;
    return self._inputs.get(name, self.output)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdd.mdd.Variable"><code class="flex name class">
<span>class <span class="ident">Variable</span></span>
<span>(</span><span>valid: BV.UnsignedBVExpr, encode: Callable[[Any], int], decode: Callable[[int], Any])</span>
</code></dt>
<dd>
<div class="desc"><p>BDD representation of a multi-valued variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Variable:
    &#34;&#34;&#34;BDD representation of a multi-valued variable.&#34;&#34;&#34;

    valid: BV.UnsignedBVExpr = attr.ib()
    encode: Callable[[Any], int]
    decode: Callable[[int], Any]

    def size(self) -&gt; int:
        &#34;&#34;&#34;Returns number of values Variable can take on.&#34;&#34;&#34;
        return aiger_bdd.count(self.valid)

    @valid.validator
    def check_bitvector_input(self, _: Attribute, value: UnsignedBVExpr):
        if len(value.inputs) != 1:
            raise ValueError(&#34;valid must be over single bitvector input!&#34;)

    @property
    def _name_bundle(self) -&gt; Tuple[str, int]:
        imap = self.valid.aigbv.imap
        (name, bundle), *_ = imap.items()
        return name, bundle

    @property
    def name(self) -&gt; str:
        return self._name_bundle[0]

    @property
    def bundle(self) -&gt; Bundle:
        return self.valid.aigbv.imap[self.name]

    def with_name(self, name: str) -&gt; Variable:
        &#34;&#34;&#34;Create a copy of this Variable with a new name.&#34;&#34;&#34;
        if self.name == name:
            return self
        valid_circ = self.valid.aigbv[&#34;i&#34;, {self.name: name}]
        return attr.evolve(self, valid=BV.UnsignedBVExpr(valid_circ))

    @property
    def _encoding_size(self) -&gt; int:
        return self.bundle.size

    def expr(self) -&gt; BV.UnsignedBVExpr:
        &#34;&#34;&#34;Returns Aiger BitVector representing this variable.&#34;&#34;&#34;
        return BV.uatom(self._encoding_size, self.name)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="mdd.mdd.Variable.decode"><code class="name">var <span class="ident">decode</span> : Callable[[int], Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="mdd.mdd.Variable.encode"><code class="name">var <span class="ident">encode</span> : Callable[[Any], int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="mdd.mdd.Variable.valid"><code class="name">var <span class="ident">valid</span> : aiger_bv.expr.UnsignedBVExpr</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="mdd.mdd.Variable.bundle"><code class="name">var <span class="ident">bundle</span> : aiger_bv.bundle.Bundle</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bundle(self) -&gt; Bundle:
    return self.valid.aigbv.imap[self.name]</code></pre>
</details>
</dd>
<dt id="mdd.mdd.Variable.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    return self._name_bundle[0]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mdd.mdd.Variable.check_bitvector_input"><code class="name flex">
<span>def <span class="ident">check_bitvector_input</span></span>(<span>self, _: Attribute, value: UnsignedBVExpr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@valid.validator
def check_bitvector_input(self, _: Attribute, value: UnsignedBVExpr):
    if len(value.inputs) != 1:
        raise ValueError(&#34;valid must be over single bitvector input!&#34;)</code></pre>
</details>
</dd>
<dt id="mdd.mdd.Variable.expr"><code class="name flex">
<span>def <span class="ident">expr</span></span>(<span>self) ‑> aiger_bv.expr.UnsignedBVExpr</span>
</code></dt>
<dd>
<div class="desc"><p>Returns Aiger BitVector representing this variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expr(self) -&gt; BV.UnsignedBVExpr:
    &#34;&#34;&#34;Returns Aiger BitVector representing this variable.&#34;&#34;&#34;
    return BV.uatom(self._encoding_size, self.name)</code></pre>
</details>
</dd>
<dt id="mdd.mdd.Variable.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns number of values Variable can take on.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def size(self) -&gt; int:
    &#34;&#34;&#34;Returns number of values Variable can take on.&#34;&#34;&#34;
    return aiger_bdd.count(self.valid)</code></pre>
</details>
</dd>
<dt id="mdd.mdd.Variable.with_name"><code class="name flex">
<span>def <span class="ident">with_name</span></span>(<span>self, name: str) ‑> <a title="mdd.mdd.Variable" href="#mdd.mdd.Variable">Variable</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a copy of this Variable with a new name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_name(self, name: str) -&gt; Variable:
    &#34;&#34;&#34;Create a copy of this Variable with a new name.&#34;&#34;&#34;
    if self.name == name:
        return self
    valid_circ = self.valid.aigbv[&#34;i&#34;, {self.name: name}]
    return attr.evolve(self, valid=BV.UnsignedBVExpr(valid_circ))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mdd" href="index.html">mdd</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mdd.mdd.to_bdd" href="#mdd.mdd.to_bdd">to_bdd</a></code></li>
<li><code><a title="mdd.mdd.to_var" href="#mdd.mdd.to_var">to_var</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mdd.mdd.DecisionDiagram" href="#mdd.mdd.DecisionDiagram">DecisionDiagram</a></code></h4>
<ul class="">
<li><code><a title="mdd.mdd.DecisionDiagram.bdd" href="#mdd.mdd.DecisionDiagram.bdd">bdd</a></code></li>
<li><code><a title="mdd.mdd.DecisionDiagram.interface" href="#mdd.mdd.DecisionDiagram.interface">interface</a></code></li>
<li><code><a title="mdd.mdd.DecisionDiagram.let" href="#mdd.mdd.DecisionDiagram.let">let</a></code></li>
<li><code><a title="mdd.mdd.DecisionDiagram.order" href="#mdd.mdd.DecisionDiagram.order">order</a></code></li>
<li><code><a title="mdd.mdd.DecisionDiagram.override" href="#mdd.mdd.DecisionDiagram.override">override</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdd.mdd.Interface" href="#mdd.mdd.Interface">Interface</a></code></h4>
<ul class="two-column">
<li><code><a title="mdd.mdd.Interface.applied" href="#mdd.mdd.Interface.applied">applied</a></code></li>
<li><code><a title="mdd.mdd.Interface.constantly" href="#mdd.mdd.Interface.constantly">constantly</a></code></li>
<li><code><a title="mdd.mdd.Interface.inputs" href="#mdd.mdd.Interface.inputs">inputs</a></code></li>
<li><code><a title="mdd.mdd.Interface.lift" href="#mdd.mdd.Interface.lift">lift</a></code></li>
<li><code><a title="mdd.mdd.Interface.output" href="#mdd.mdd.Interface.output">output</a></code></li>
<li><code><a title="mdd.mdd.Interface.valid" href="#mdd.mdd.Interface.valid">valid</a></code></li>
<li><code><a title="mdd.mdd.Interface.var" href="#mdd.mdd.Interface.var">var</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdd.mdd.Variable" href="#mdd.mdd.Variable">Variable</a></code></h4>
<ul class="">
<li><code><a title="mdd.mdd.Variable.bundle" href="#mdd.mdd.Variable.bundle">bundle</a></code></li>
<li><code><a title="mdd.mdd.Variable.check_bitvector_input" href="#mdd.mdd.Variable.check_bitvector_input">check_bitvector_input</a></code></li>
<li><code><a title="mdd.mdd.Variable.decode" href="#mdd.mdd.Variable.decode">decode</a></code></li>
<li><code><a title="mdd.mdd.Variable.encode" href="#mdd.mdd.Variable.encode">encode</a></code></li>
<li><code><a title="mdd.mdd.Variable.expr" href="#mdd.mdd.Variable.expr">expr</a></code></li>
<li><code><a title="mdd.mdd.Variable.name" href="#mdd.mdd.Variable.name">name</a></code></li>
<li><code><a title="mdd.mdd.Variable.size" href="#mdd.mdd.Variable.size">size</a></code></li>
<li><code><a title="mdd.mdd.Variable.valid" href="#mdd.mdd.Variable.valid">valid</a></code></li>
<li><code><a title="mdd.mdd.Variable.with_name" href="#mdd.mdd.Variable.with_name">with_name</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>